# The critical transition between neutral and competitive communities 

I use here the following neutral model with power dispersal kernel:

<https://github.com/lsaravia/Neutral>

I generate parameter files for the simulation of neutral/hierarchical model using a uniform and a logseries metacommunity distribution  


```{r setup, eval=T }
load(".RData")
#simul  <- F # variable to perform or not the simulations

oldcd <-getwd()
source("R/Neutral_fun.r")

# Set the location of the binary 
#
neuBin <- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralPow"
neuBin64<- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralP64"


require(pander)
require(plyr)
require(dplyr)

panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')
options("scipen"=100, "digits"=6)
```

## Neutral Simulations to reach steady state


Now I will simulate the model wiht side=100 64 sp to Time=3000 with  
Differnt ReplacementRate and 30 repetitions 


```{r gensimul100_64_U5_T20000, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 100
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.005,0.01,0.05,0.1,0.5,1)
time <- 20000

# loop con do paralell 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()


CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],TRUE,time,nSimul,"N","L","N",TRUE)
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],FALSE,time,nSimul,"N","L")
  CT1 <-rbind(CT1,kk)
}

# Calculation of stationarity statistics with a window 
#
wps<-data.frame()
for(i in 1:length(ReplRate)){
  kk<-ts_ADTest_PlotTime(nsp,side,alfa,m,ReplRate[i],time,"L",10,TRUE)              
  wps <- rbind(wps,kk) 
}


# Correct CT add Time, variable metatype
CT1$Time <- time
CT1$IniCond <- "Filled"   # Lattice filled with metacommunity SAD

#CT <- CT %>% mutate(IniCond=ifelse(TMaxH==1,"Filled","Empty"))

CT <- rbind(CT,CT1)

setwd(oldcd)

prop_stationary <- CT %>% group_by(MetaNsp,Side,Disp,Migr,Repl,MetaType,Time) %>% mutate(num_SAD_AD=(SAD_ADpval>0.05),num_H_PP=(H_PPpval<0.05),num_H_KPSS=(H_KPSSpval>0.05),num_H_both=(H_PPpval<0.05)&(H_KPSSpval>0.05)) %>% summarise(prop_H_KPSS=sum(num_H_KPSS)/n(),prop_H_PP=sum(num_H_PP)/n(),prop_H_both=sum(num_H_both)/n(),prop_SAD_AD=sum(num_SAD_AD)/n())

rm(kk,CT1,wps)
save.image()


```

## Time series simulations for side=256 time=20000 logseries metacomunity   

```{r plotsimul256_64_L5_T20000, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.005,0.01,0.05,0.1,0.5,1)
time <- 20000
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()


CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N","L","N",TRUE)
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,time,nSimul,"N","L")
}


# Calculation of stationarity statistics with a window 
#
wps <-data.frame()
for(i in 1:length(ReplRate)){
  kk<-ts_ADTest_PlotTime(nsp,side,alfa,m,ReplRate[i],time,"L",10,TRUE)              
  wps <- rbind(w_prop_stationary,kk) 
}


# Correct CT add Time
CT1$Time <- time
CT1$IniCond <- "Filled"   # Lattice filled with metacommunity SAD

CT <- rbind(CT,CT1)

setwd(oldcd)


# Calculate a summary with the proportion of runs with stationarity (prop_SAD_AD)
# 
#
prop_stationary <- CT %>% group_by(MetaNsp,Side,Disp,Migr,Repl,MetaType,Time) %>% mutate(num_SAD_AD=(SAD_ADpval>0.05),num_H_PP=(H_PPpval<0.05),num_H_KPSS=(H_KPSSpval>0.05),num_H_both=(H_PPpval<0.05)&(H_KPSSpval>0.05)) %>% summarise(prop_H_KPSS=sum(num_H_KPSS)/n(),prop_H_PP=sum(num_H_PP)/n(),prop_H_both=sum(num_H_both)/n(),prop_SAD_AD=sum(num_SAD_AD)/n())

rm(kk,CT1)
save.image()
```

## Time series simulations : Side 512, time=20000 metacommunity=L

```{r plotsimul512_64_L5_T20000, eval=F,echo=T,message=T,warning=T}

setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.005,0.01,0.05,0.1,0.5,1)
time <- 20000                                     # aprox 1.8 min per simulation 

# Make simulations 
#
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()

CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N","L","N",TRUE)
}
stopCluster(cl)
rm(cn,cl)

# Make the plots!
#
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,time,nSimul,"N","L")
#  CT1 <- bind_rows(CT1,kk)
}

# Calculation of stationarity statistics with a window 
#
# 
# for(i in 1:length(ReplRate)){
#   kk<-ts_ADTest_PlotTime(nsp,side,alfa,m,ReplRate[i],time,"L",10,TRUE)              
#   wps <- rbind(wps,kk) 
# }


# Correct CT add Time
CT1$Time <- time
CT1$IniCond <- "Filled"   # Lattice filled with metacommunity SAD
CT <- bind_rows(CT,CT1)

setwd(oldcd)


#
# Calculate a summary with the proportion of runs with stationarity (prop_SAD_AD)
# 
# H_PPVal has to be less than 0.05, to reject non-stationarity
# H_KPSSpval has to be >0.05 to accept stationarity
# 
#
prop_stationary <- CT %>% group_by(MetaNsp,Side,Disp,Migr,Repl,MetaType,Time,IniCond) %>% mutate(num_SAD_AD=(SAD_ADpval>0.05),num_H_PP=(H_PPpval<0.05),num_H_KPSS=(H_KPSSpval>0.05),num_H_both=(H_PPpval<0.05)&(H_KPSSpval>0.05)) %>% summarise(prop_H_KPSS=sum(num_H_KPSS)/n(),prop_H_PP=sum(num_H_PP)/n(),prop_H_both=sum(num_H_both)/n(),prop_SAD_AD=sum(num_SAD_AD)/n())


rm(kk,CT1)
save.image()

```


## Time series simulations for side=512 time=20000 uniform metacomunity   


```{r plotsimul512_64_U5_T20000, eval=T,echo=F,message=F,warning=F}

setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.005,0.01,0.05,0.1,0.5,1)
time <- 20000
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()

CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N","U","N",TRUE)
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,time,nSimul,"N","U")
}


# Calculation of stationarity statistics with a window 
#
# 
# for(i in 1:length(ReplRate)){
#   kk<-ts_ADTest_PlotTime(nsp,side,alfa,m,ReplRate[i],time,"L",10,TRUE)              
#   w_prop_stationary <- rbind(w_prop_stationary,kk) 
# }

# Correct CT add Time 
CT1$Time <- time
CT1$IniCond <- "Filled"   
CT <- rbind(CT,CT1)

setwd(oldcd)

# Calculate a summary with the proportion of runs with stationarity (prop_SAD_AD)
# 
#
prop_stationary <- CT %>% group_by(MetaNsp,Side,Disp,Migr,Repl,MetaType,Time,IniCond) %>% mutate(num_SAD_AD=(SAD_ADpval>0.05),num_H_PP=(H_PPpval<0.05),num_H_KPSS=(H_KPSSpval>0.05),num_H_both=(H_PPpval<0.05)&(H_KPSSpval>0.05)) %>% summarise(prop_H_KPSS=sum(num_H_KPSS)/n(),prop_H_PP=sum(num_H_PP)/n(),prop_H_both=sum(num_H_both)/n(),prop_SAD_AD=sum(num_SAD_AD)/n())

rm(kk,CT1)
save.image()
```



## Simulations for Uniform and Logseries side =100,256,512 species=64 1T=3000


The critical probability is very low around 0.002 thus most communities should be in a "niche" state but the transient time is very long unless rho is relatively high.

## Conclusions if a species have a spanning cluster of about 30% of the total area, they are near the critical point.


## Simulations to Time=5000 

```{r gensimul_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i])
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```

# Calculation of the critical point T=3000

```{r logfit_clu_side_64_meta30, eval=F,echo=F,message=T,warning=T}

m <-  round(0.0001596079,9)
alfa<-round(2.038974,5)
side <- 512
nsp <- 64
nSimul <- 30

require(plyr)
require(dplyr)

mClusters <- filter(Clusters, Time==3000,MetaNsp==nsp,DispersalDistance==alfa,ColonizationRate==m) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))

require(ggplot2)

#
# Calculates the probability of spanning cluster
#

k <- group_by(mClusters, MetaType,Side) %>% mutate(near=abs(SpanningProb-0.5),n=n()) %>% arrange(near) %>% filter(near<0.35)

k <-group_by(mClusters, MetaType,Side) %>% filter(ReplacementRate>0  & ReplacementRate<0.004) 
# DELETE RECORDS 
k <- k[-c(3,13,16),]

k <- k %>% summarise(pcrit=approx(SpanningProb,ReplacementRate,xout=0.5)[["y"]],critClust=approx(SpanningProb,SpanningClust,xout=0.5)[["y"]])

require(pander)
pandoc.table(k,round=5)

#
# finite size scaling to determine pcrit for infinite lattices
#
k1 <- group_by(k,MetaType) %>% mutate(iSide=1/(Side*Side) ) %>% do(model=lm(pcrit ~ iSide, data=.)) %>% summarise(pcrit=predict(model,newdata=data.frame(iSide=0)),pcSE=predict(model,newdata=data.frame(iSide=0),se.fit=T)$se.fit)            
   
k1$MetaType <- c("L","U") 
k1$iSide <- 0 
k1

ggplot(k,aes(x=1/(Side*Side),y=pcrit,colour=MetaType)) + geom_point() + theme_bw() +stat_smooth(method=lm,se=F) + geom_point(data=k1,aes(x=iSide,y=pcrit),shape=21)

#
# Spaninng probability vs rho
#
ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red") + geom_vline(aes(xintercept=pcrit),k,colour="green")

# Select Time and change label of MetaType
#
tClusters <- Clusters %>% filter(Time==3000)  %>% mutate(MetaType=factor(MetaType,labels=c("Logseries","Uniform")))
k$MetaType <- factor(k$MetaType,labels=c("Logseries","Uniform"))


#
# Shannon diversity vs rho
#
ggplot(tClusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/HvsRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# Richness vs rho
#
ggplot(tClusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y") +xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/RichvsRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)


##
# Proportion of Selected models 
# 

tot_fit_by_model <- all_fit %>% group_by(region,subregion,model_set,model_name) %>% mutate(tot_by_model=n()) %>% 
	filter(delta_AICc==0) %>% summarise(best_model_prop=n()/max(tot_by_model)) %>% select(model_name,best_model_prop) %>% arrange(desc(best_model_prop)) %>% filter(model_set=="Estimated Xmin") 


# Plot of Spanning clusters sizes with critical probability
#
ggplot(tClusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")

ggsave("figs/SpanClusRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

```

# Calculation of the critical point T=5000 DispersalDistance=26 m=0.00016 (Add side=150)

```{r pcT5000_clu_side_64_meta30, eval=F,echo=F,message=T,warning=T}

m   <-round(0.0001596079,9)
alfa <-round(2.03897,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

require(plyr)
require(dplyr)

# Calculates critical probabilities for differnt side (rCTs) and critical probability for infinite lattices (rCT)
#
k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

require(ggplot2)
require(pander)

# Create data frame to store Pc for lattices with different sides
rhoCritSide <- data_frame()

# Update table after recalculation of critical points
#rhoCritSide <- filter(rhoCritSide,DispersalDistance!=26.66 | ColonizationRate!=0.000159608 | MetaNsp!=64)
rhoCritSide <- rbind(rhoCritSide,k$rCTs)
pandoc.table(rhoCritSide,round=5)

# Create data frame to store Pc for infinite lattices
rhoCrit <- data_frame()
# 
#rhoCrit <- filter(rhoCrit,DispersalDistance!=26.66 | ColonizationRate!=0.000159608 | MetaNsp!=64)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)

# Make with different sides filter side=150
# 
k<-filter(rhoCritSide,MetaNsp==nsp,DispersalDistance==round(mean_power(alfa),2),ColonizationRate==m,Side!=150)
k$MetaType <- factor(k$MetaType,labels=c("Logseries","Uniform"))

mClusters <- filter(Clusters, Time==5000,MetaNsp==nsp,DispersalDistance==alfa,ColonizationRate==m,Side!=150) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance,ColonizationRate) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))  %>% ungroup() %>% mutate(MetaType=factor(MetaType,labels=c("Logseries","Uniform")))

#
# Spaninng probability vs rho
#
ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red") + geom_vline(aes(xintercept=pcrit),k,colour="green") + ylab("Probability of spanning cluster")
ggsave("figs/SpanPvsRepl_T5000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# The same Plot in linear x scale 
#
ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + xlim(0,0.02) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red") + geom_vline(aes(xintercept=pcrit),k,colour="green") + ylab("Probability of Spanning cluster")
ggsave("figs/SpanPvsRepl_T5000_64_side_meta_lin.png", width=6,height=6,units="in",dpi=600)


#
# Shannon diversity vs rho
#
tClusters <- Clusters %>% filter(Time==5000,MetaNsp==64)  %>% mutate(MetaType=factor(MetaType,labels=c("Logseries","Uniform")))


tClusters <- Clusters %>% filter(Time==time,MetaNsp==nsp,DispersalDistance==alfa,ColonizationRate==m,Side!=150)  %>% mutate(MetaType=factor(MetaType,labels=c("Logseries","Uniform")))

#
# H vs rho
#
ggplot(tClusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/HvsRepl_T5000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# H vs rho in linear x scale 
#
require(grid)
ggplot(tClusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.2) + theme_bw() + xlim(0,0.02) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green") + theme(panel.margin.x=unit(0.6, "lines"))
ggsave("figs/HvsRepl_T5000_64_side_meta_lin.png", width=6,height=6,units="in",dpi=600)


#
# Richness vs rho
#
ggplot(tClusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y") +xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/RichvsRepl_T5000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# Richness vs rho linear scale
#
ggplot(tClusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")


#
# Plot of Spanning clusters sizes with critical probability
#
ggplot(tClusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")

ggsave("figs/SpanClusRepl_T5000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# The same Plot in linear x scale 
#
ggplot(tClusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.2) + theme_bw() + xlim(0,0.02)  + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")


rm(k,k1,p,mClusters,tClusters)
```

## Plot SAD for side=100,254 uniform metacommunity

```{r plotsad_256_64_U30, eval=F,echo=F,message=T,warning=T}

time <- 3000
ReplRate <- c(0.0000,0.0005,0.0010,0.0020,0.0050,0.0100,0.0200,0.0500,0.1000,1)
setwd("Simul")

plotNeutral_SAD_1T(64,100,ReplRate,time)

plotNeutral_SAD_1T(64,256,ReplRate,time)

plotNeutral_SAD_1T(64,100,ReplRate,time,"L")

plotNeutral_SAD_1T(64,256,ReplRate,time,"L")


# Plots of logseries and uniform metacommunity SAD 

mc <- c("#a50026","#d73027","#f46d43","#fdae61","#fee090","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695")

#
# What happens at time=5000
#
options("scipen"=0, "digits"=4)

time <- 5000
# kk <- Clusters %>% filter(Time==time) %>% group_by(Side,MetaType,ReplacementRate) %>% summarise(n=n())
# unique(kk$ReplacementRate)

# ADD 
ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

rank <- plotNeutral_SAD_1T(64,512,ReplRate,time,"L",T)
rank$MetaType="Logseries"
r1 <-  plotNeutral_SAD_1T(64,512,ReplRate,time,"U",T) 
r1$MetaType="Uniform"
rank <- rbind(rank,r1)
rank$Time <- time
rm(r1)

options("scipen"=100, "digits"=6)
colourCount = length(unique(rank$ReplacementRate))
mc1 <- colorRampPalette(mc)(colourCount)
mc1[11]<-"#0D0D0D" # rho=0.0015
g <- ggplot(rank,aes(x=Rank,y=log(Freq),colour=factor(ReplacementRate))) +  theme_bw() 
g + scale_colour_manual(values=mc1,name=bquote("  "~rho),breaks=c(0.0000,0.0005,0.0010,0.0015,0.0020,0.0050,0.0100,0.1000,1))  + geom_line() + facet_grid(. ~ MetaType, scales="free_x" )

#g + scale_colour_discrete(name=bquote("  "~rho))  + geom_line() + facet_grid(. ~ MetaType, scales="free_x" )
setwd(oldcd)
ggsave("figs/SAD_T5000_64_512_meta.png", width=6,height=4,units="in",dpi=600)

#
# Time =3000
# 
setwd("Simul")

time<-3000
r1 <- plotNeutral_SAD_1T(64,512,ReplRate,time,"L",T)
r1$MetaType="Logseries"
r1$Time <- time
rank <- rbind(rank,r1)

r1 <-  plotNeutral_SAD_1T(64,512,ReplRate,time,"U",T) 
r1$MetaType="Uniform"
r1$Time <- time
rank <- rbind(rank,r1)
rm(r1)

g <- ggplot(rank,aes(x=Rank,y=log(Freq),colour=factor(ReplacementRate))) +  theme_bw() #+ geom_point(size=1,shape=c(21))
g + scale_colour_manual(values=mc,name=bquote("  "~rho))  + geom_line() + facet_grid(Time ~ MetaType, scales="free_x" )
#g + scale_colour_discrete(name=bquote("  "~rho))  + geom_line() + facet_grid(. ~ MetaType, scales="free_x" )
setwd(oldcd)
ggsave("figs/SAD_Time_64_512_meta.png", width=6,height=6,units="in",dpi=600)

```


## Simulations to Time=5000 to graph spatial patterns 

```{r gensimul_spat_256_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 1


#ReplRate <- c(0,0.1)
ReplRate <- c(0.0000,0.0005,0.0010,0.0013,0.0016,0.0020,0.0050,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)
#time <- 3000
time <- 5000

p <-expand.grid(disp=2.038974,migr=0.0001596079,repl=ReplRate,side=side,meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
  simul_NeutralSAD(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,p$meta[i],F)
}

stopCluster(cl)

setwd(oldcd)

rm(cn,cl,Clu)

#save.image()
```

# Plot spatial patterns

```{r pltsimul_spat_512_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 1

ReplRate <- c(0.0000,0.0005,0.0010,0.0013,0.0016,0.0020,0.0050,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

ReplRate <- c(0.0000,0.0005,0.0010,0.0013)
ReplRate <- c(0.0000,0.0013,0.0020,0.0050)
time <- 5000

#ReplRate <- c(0.1)
options("scipen"=0, "digits"=4)

# only the spanning species
plotNeutral_SpatPat(nsp,side,time,meta=c("U"),ReplRate,T)
setwd(oldcd)
ggsave("figs/SpatSpan_Repl_T5000_64_256_Unif.png", width=6,height=6,units="in",dpi=600)

setwd("Simul")
ReplRate <- c(0.0000,0.0013,0.0020,0.0050)
plotNeutral_SpatPat(nsp,side,time,meta=c("L"),ReplRate,T)
setwd(oldcd)
ggsave("figs/SpatSpan_Repl_T5000_64_256_Logser.png", width=6,height=6,units="in",dpi=600)

# All species
setwd("Simul")
plotNeutral_SpatPat(nsp,side,time,meta=c("U"),ReplRate,F)
setwd(oldcd)
ggsave("figs/SpatAllSp_Repl_T5000_64_256_Unif.png", width=6,height=6,units="in",dpi=600)

plotNeutral_SpatPat(nsp,side,time,meta=c("L"),ReplRate,F)


```

## Regenerate Clusters data.frame from files in Simul folder

```{r regen_clust_512_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30
time <- 3000

require(dplyr)


mClusters <- filter(Clusters, Time==time) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))
ReplRate <- unique(mClusters$ReplacementRate)


p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 

Clu <- data.frame()
for(i in 1:nrow(p))
  {
  Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
  }

kk <-filter(Clu, Time==5000) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance) %>% summarise(n=n())

Clusters <- filter(Clusters, !(Time==5000)) #%>% distinct()

# Eliminate firs simulations with metacommunity of 86 sp
#
Clusters <- filter(Clusters, MetaNsp==64) #%>% distinct()

Clusters <-rbind(Clusters,Clu)

setwd(oldcd)

rm(mClusters,p,kk,cn,cl,Clu)

save.image()


```


## Simulations to Time=5000 with migration=0.00016 dispersal=13

```{r simuldisp13_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}

# Calculate dispersal parameter for half the mean distance from @Anand2010 DispersalDistance=13
#
ana <- read.table("Data/Anand2010_DD.dat", header=T)
m_DD <-mean(ana$DD)
m_DD <- m_DD/2
mean_power_opt <-function(alfa,x=1) abs(((alfa-1)/(alfa-2)*x)-m_DD)
optimize(mean_power_opt,c(2,4))
mean_power(2.081069)

setwd("Simul")


m <-  0.0001596079
alfa <- 2.081069
side <- 512
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```



# Calculation of the critical point T=5000 migration=0.00016 dispersal=13  (Add Side=150)

```{r pcT5000_clu_side_64_disp13, eval=F,echo=F,message=T,warning=T}

m <-  round(0.0001596079,9)
alfa <- round(2.081069,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

rhoCritSide <- rbind(rhoCritSide,k$rCTs)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)



plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1)
save.image()

```

There seem to be no big changes in critical point with regard to dispersal distance 

## Simulations to Time=5000 with migration=0.0016 dispersal distance =26.66


```{r gensimul_m10_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30
ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#time <- 100
time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```

# Plot Critical Clusters H and Richness vs Replacement rate for migration=0.0016 dispersal=26.66 (Add Side=150)

```{r pcT5000_clu_side_64_m0016_disp26, eval=F,echo=F,message=T,warning=T}

m <-  round(0.001596079,8)
alfa<-round(2.038974,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

#filter(rhoCritSide,DispersalDistance==round(mean_power(alfa),2) & ColonizationRate==m & MetaNsp==nsp)
#rhoCritSide <-filter(rhoCritSide,DispersalDistance!=round(mean_power(alfa),2) | ColonizationRate!=m | MetaNsp!=nsp)
rhoCritSide <- rbind(rhoCritSide,k$rCTs)

#filter(rhoCrit,DispersalDistance==round(mean_power(alfa),2) & ColonizationRate==m & MetaNsp==nsp)
#rhoCrit <- filter(rhoCrit,DispersalDistance!=round(mean_power(alfa),2) | ColonizationRate!=m | MetaNsp!=nsp)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)


plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1,mClusters)
save.image()
```


## Simulations to Time=5000 with migration=0.016 dispersal distance =26


```{r gensimul_m100_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.01596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30
ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#time <- 100
time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```


# Plot critical point for m=0.016 dispersal=26.67 (add Side=150)

```{r pcT5000_clu_side_64_m016_disp26, eval=F,echo=F,message=T,warning=T}

m   <-round(0.01596079,7)
alfa <-round(2.038974,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

rhoCritSide <- rbind(rhoCritSide,k$rCTs)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)

plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1,mClusters)
save.image()

```


* With so high migration rate there is no fall in richness and the fall in H is gentler but the critical behavior is maintained, thus there is a spanning cluster but it occupies less proportion of the landscape allowing more species to coexist.


## Simulations to Time=5000 with migration=0.00016 dispersal distance =6.66

```{r simuldisp6_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}

# Calculate dispersal parameter for 1/4 the mean distance from @Anand2010 DispersalDistance=13
#
# ana <- read.table("Data/Anand2010_DD.dat", header=T)
# m_DD <-mean(ana$DD)
# m_DD <- m_DD/4
# mean_power_opt <-function(alfa,x=1) abs(((alfa-1)/(alfa-2)*x)-m_DD)
# optimize(mean_power_opt,c(2,4))
# mean_power(2.17641)

setwd("Simul")


m <-  0.0001596079
alfa <- 2.17641
side <- 512
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)


time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```

# Plot critical point for m=0.00016 dispersal=6.67 (add Side=150)

```{r pcT5000_clu_side_64_m016_disp6, eval=F,echo=F,message=T,warning=T}


# To find the value of m
#
# filter(Clusters, Time==time,MetaNsp==nsp,DispersalDistance==alfa) %>% distinct(ColonizationRate)
m   <-round(0.0001596079,9)
alfa <-round(2.17641,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

rhoCritSide <- rbind(rhoCritSide,k$rCTs)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)

require(ggplot2)
require(dplyr)
g1 <-ggplot(filter(rhoCrit,round(DispersalDistance,1)==26.7,MetaNsp==64),aes(x=ColonizationRate,y=pcrit,colour=MetaType)) + geom_point() + geom_errorbar(aes(ymin=pcrit-pcSE, ymax=pcrit+pcSE), width=0)+ scale_x_log10(breaks=c(0.00015,0.0015,0.015)) + theme_bw() + xlab("Migration") + ylab(bquote(rho[c])) + scale_colour_discrete(guide=FALSE)
g1
ggsave("figs/CritProb_Migr_T5000_64_meta.png", width=4,height=4,units="in",dpi=600)

#rhoCrit <- mutate(rhoCrit,ColonizationRate=ifelse(ColonizationRate==0.0001596079,0.000159608,ColonizationRate))

g2 <-ggplot(filter(rhoCrit,round(ColonizationRate,9)==0.000159608,MetaNsp==64),aes(x=DispersalDistance,y=pcrit,colour=MetaType)) + geom_point() + geom_errorbar(aes(ymin=pcrit-pcSE, ymax=pcrit+pcSE), width=.1)+ theme_bw() +xlab("Dispersal Distance") + ylab(bquote(rho[c]))  + scale_colour_discrete(guide=FALSE)
g2
ggsave("figs/CritProb_Disp_T5000_64_meta.png", width=4,height=4,units="in",dpi=600)


g3 <- ggplot(filter(rhoCrit,round(ColonizationRate,9)==0.000159608,round(DispersalDistance,1)==26.7),aes(x=MetaNsp,y=pcrit,colour=MetaType)) + geom_point() + geom_errorbar(aes(ymin=pcrit-pcSE, ymax=pcrit+pcSE), width=.1)+ theme_bw() +xlab("Metacomm no. species") + ylab(bquote(rho[c]))  + scale_colour_discrete(name="Metacomm.\nType") + theme(legend.justification=c(1,0),legend.position=c(1,0))
g3
ggsave("figs/CritProb_MetaNsp_T5000_64_meta.png", width=4,height=4,units="in",dpi=600)

plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1,mClusters,g1,g2,g3)
save.image()

```

## Simulations to Time=5000 with side=150, varying migration and dispersal to add to finite size scaling 

```{r simuldisp_clu_side150_meta64_n30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


side <- 150
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time <- 5000

m  <- 0.0001596079
alfa <-c(2.038974,2.081069,2.17641) #26,13,6.6

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(150),meta=c("U","L")) 

m <-  c(0.0001596079,0.001596079,0.01596079)
alfa <-2.038974

p <-rbind(p,expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(150),meta=c("U","L")) )

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()

```

## Simulations to Time=5000 with side=100-512, dispersal=26 migration=0.0001596079 species=256 

```{r simuldisp_clu_side512_meta256_n30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


side <- c(100,150,256,512)
nsp <- 256
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#ReplRate <- c(0.0000,0.0007,0.0022,0.0028)
time <- 5000

m  <- 0.0001596079
alfa <-2.038974

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=side,meta=c("U","L")) # ,"L"

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

# Last T/F deletes or not previous simulations
#
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Read simulations info and add it to Clusters data.frame
#
# for(i in 1:nrow(p))
# {
#     Clu <- bind_rows(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i],F))
#   
# }

stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(p,cn,cl,Clu)

save.image()

```

```{r pcT5000_clu_side_256_meta256_disp26, eval=F,echo=F,message=T,warning=T}

side <- c(100,150,256,512)
nsp <- 256
time <- 5000

m   <-round(0.0001596079,9)
alfa <-round(2.038974,5)

rl <- calcCritical_prob(Clusters,time,nsp,alfa,m)
#rhoCritSide <- filter(rhoCritSide,MetaNsp==64)
rhoCritSide <- rbind(rhoCritSide,rl$rCTs)
rhoCrit <- rbind(rhoCrit,rl$rCT)

plotCritical_Clusters(Clusters,time,nsp,alfa,m,rhoCritSide)


```

## Simulations to Time=5000 with side=100-512, dispersal=26 migration=0.0001596079 species=16 

```{r simuldisp_clu_side512_meta16_n30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


side <- c(100,150) #c(100,150,256,512)
nsp <- 16
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#ReplRate <- c(0.0000,0.0007,0.0022,0.0028)
time <- 5000

m  <- 0.0001596079
alfa <-2.038974

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=side,meta=c("U","L")) # ,"L"

# Read simulations info and add it to Clusters data.frame 
# use it in case of broken simulations

# Clu <- data.frame()
# for(i in 1:nrow(p))
# {
#     Clu <- bind_rows(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i],F))
#   
# }

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

# Last parameter to delete previous simulations
#
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],T)
}

stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(p,cn,cl,Clu)

save.image()
```

```{r pcT5000_clu_side_256_meta16_disp26, eval=F,echo=F,message=T,warning=T}


m   <-round(0.0001596079,9)
alfa <-round(2.038974,5)
time <- 5000
nsp<-16

rl <- calcCritical_prob(Clusters,time,nsp,alfa,m) #Exclude Side=100

# Update table after recalculation of critical points
#rhoCritSide <- filter(rhoCritSide,DispersalDistance!=26.66 | ColonizationRate!=0.000159608 | MetaNsp!=16)
rhoCritSide <- rbind(rhoCritSide,rl$rCTs)
rhoCrit <- rbind(rhoCrit,rl$rCT)

# Save figures
#
plotCritical_Clusters(Clusters,time,nsp,alfa,m,rhoCritSide,150,T)

#
# Tables for paper
#
require(pander)
pandoc.table(filter(rhoCritSide,DispersalDistance==26.66,ColonizationRate==m, MetaNsp==64) %>% select(c(1,4:6)),round=5)

options("scipen"=100, "digits"=6)
pandoc.table(select(rhoCrit,c(6,1:5)) %>% arrange(ColonizationRate,desc(DispersalDistance),MetaNsp,MetaType)
             ,round=5)

# Calculation of the relative variation of each variable
#
senRhoCri <- filter(rhoCrit,ColonizationRate==round(0.0001596079,9),MetaNsp==64) %>% group_by(MetaType) %>% summarize(var="Dispersal",delta_pc=(max(pcrit) - min(pcrit))/max(pcrit), delta_var=(max(DispersalDistance) - min(DispersalDistance))/max(DispersalDistance),rv_var=delta_pc/delta_var)

senRhoCri <- bind_rows(senRhoCri, filter(rhoCrit,ColonizationRate==round(0.0001596079,9),DispersalDistance==26.66) %>% group_by(MetaType) %>% summarize(delta_pc=(max(pcrit) - min(pcrit))/max(pcrit), delta_var=(max(MetaNsp) - min(MetaNsp))/max(MetaNsp),rv_var=delta_pc/delta_var,var="MetaNsp"))

senRhoCri <- bind_rows(senRhoCri, filter(rhoCrit,MetaNsp==64,DispersalDistance==26.66) %>% group_by(MetaType) %>% summarize(delta_pc=(max(pcrit) - min(pcrit))/max(pcrit), delta_var=(max(ColonizationRate) - min(ColonizationRate))/max(ColonizationRate),rv_var=delta_pc/delta_var,var="Colonization"))

pandoc.table(senRhoCri,round=2)

```

With 16 species and logseries community the most abundant species have a nonzero probability to form a spanning cluster, if we take out neutral communities we can still calculate a critical point.



# Simulate to estimate distributions of patch sizes statistics

```{r simuldisp26_cluAll_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd(oldcd)
source("R/powerlaw/discpowerexp.R")
source("R/powerlaw/discexp.R")
source("R/powerlaw/powerexp.R")
source("R/powerlaw/exp.R")
source("R/powerlaw/pareto.R")
source("R/powerlaw/zeta.R")

setwd("Simul")


m <-  0.0001596079
alfa <- 2.038974
side <- 256
nsp <- 64
nSimul <- 10
time <- 5000
#time <- 100
ReplRate <- c(0.0000,0.0005,0.0010,0.0020,0.0030,0.004,0.005,0.01)
p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(256),meta=c("U","L")) 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)
Models <- data.frame()
Mdl <- data.frame()
Mdl <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_Clusters(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"A",time,nSimul,F,"N",p$meta[i],F)
}

stopCluster(cl)
setwd(oldcd)

Models <- rbind(Models,Mdl)

rm(cn,cl,Mdl,p)

save.image()

```


# Plot the cluster sizes with fitted functions
 
```{r plotFitdisp26_cluAll_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
source("R/powerlaw/discpowerexp.R")
source("R/powerlaw/discexp.R")
source("R/powerlaw/powerexp.R")
source("R/powerlaw/exp.R")
source("R/powerlaw/pareto.R")
source("R/powerlaw/zeta.R")

setwd("Simul")


m <-  0.0001596079
alfa <- 2.038974
side <- 256
nsp <- 64
nSimul <- 10
time <- 5000
ReplRate <- c(0.0000,0.0005,0.0010,0.0020,0.0030,0.004,0.005,0.01)
p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(256),meta=c("U","L")) 

for(i in 1:nrow(p)){
  plotNeutral_Clusters(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],time,p$meta[i],Models)
}
setwd(oldcd)

```

# Plot relation of power exponent/ exponential rate with ReplacementRate

```{r plotdisp26_cluAll_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd(oldcd)

#
# Hacer grafico con proporcion de ajustes 
require(ggplot2)
require(plyr)
require(dplyr)
Models <- ungroup(Models)


# Power laws best models 
#
nMdl <-group_by(Models,MortalityRate,DispersalDistance,ColonizationRate,ReplacementRate,MetaType,Rep) %>% filter(DeltaAIC>0, model=="PowExp")

# Proportion of best models by model only
#
group_by(Models,model) %>% filter(DeltaAIC==0)  %>% summarise(n=n()) %>% ungroup() %>% mutate(Frequency=n/sum(n))

namType <- c("Spanning","MaxPatch","Other MaxPatch","Other Spanning")
namTypeAb <- c("Spanning/+Abundant","Spanning/+Abundant","Other Species","Other Species")

mMdl <- group_by(Models,model,type) %>% filter(DeltaAIC==0)  %>% summarise(n=n()) %>% ungroup() %>% mutate(Frequency=n/sum(n),type=namType[type])

mc <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
ggplot(mMdl, aes(x=model,y=Frequency,fill=type)) + geom_bar(stat="identity") +  scale_fill_manual(values=mc,name="Species",breaks=c("Spanning","MaxPatch","Other Spanning","Other MaxPatch")) + scale_x_discrete(labels=c("No Model","Power","Power Exp.")) + theme_bw()
ggsave("figs/ClusModels_T5000_64_256_Logser.png", width=6,height=6,units="in",dpi=600)

require(pander)
pandoc.table(mMdl,round=2)


# Select Power w/exponential cutoff other sp most abundant or other spanning
#
mMdl <- filter(Models,model=="PowExp",type==3 | type==4) %>% mutate(typeAb=namTypeAb[type],type=namType[type])

# Plot lambda - exponential decay rate
#
ggplot(mMdl,aes(x=ReplacementRate,y=rate,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=median,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(lambda)) + xlab(bquote(rho))+ scale_colour_manual(values=mc) +stat_quantile(alpha=0.5) + coord_cartesian(ylim=c(-0.02,0.65))
ggsave("figs/discRateOther_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)

# Quantile regression lambda
#
#
rqm <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(rate~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="lambda")


# Plot power exponent alpha
#
mMdl <- filter(Models,model=="PowExp",type==3 | type==4) %>% mutate(typeAb=namTypeAb[type],type=namType[type])

ggplot(mMdl,aes(x=ReplacementRate,y=alfa,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=median,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(alpha)) + xlab(bquote(rho))+ scale_colour_manual(values=mc)+stat_quantile(alpha=0.5)+ coord_cartesian(ylim=c(1.1,2.1))

ggsave("figs/discExpOther_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)


# Quantile regression alpha
#
#
rq1 <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(alfa~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="alpha")

rqm <- rbind(rqm,rq1)

# Select Power w/exponential cutoff - spanning or most abundant  sp
#
mMdl <- filter(Models,model=="PowExp",type==1 | type==2) %>% mutate(typeAb=namTypeAb[type],type=namType[type])


# Plot Power exponent - alpha  of spanning or most abundant  sp
#
ggplot(mMdl,aes(x=ReplacementRate,y=alfa,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=mean,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(alpha)) + xlab(bquote(rho)) + scale_colour_manual(values=mc)+stat_quantile(alpha=0.5)+ coord_cartesian(ylim=c(1.5,3.6))
ggsave("figs/discExpSpan_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)

# Quantile regression alpha
#
#
rq1 <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(alfa~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="alpha")

rqm <- rbind(rqm,rq1)

# Select Power w/exponential cutoff - spanning or most abundant  sp
#
mMdl <- filter(Models,model=="PowExp",type==1 | type==2) %>% mutate(typeAb=namTypeAb[type],type=namType[type])

# Plot Exponential rate - lambda of spanning or  most abundant sp
#
ggplot(mMdl,aes(x=ReplacementRate,y=rate,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=mean,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(lambda)) + xlab(bquote(rho))+ scale_colour_manual(values=mc)+stat_quantile(alpha=0.5)+ coord_cartesian(ylim=c(-0.02,0.32))
ggsave("figs/discRateSpan_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)

# Quantile regression lambda
#
#
rq1 <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(rate~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="lambda")

rqm <- rbind(rqm,rq1)
rqm$slope<-c(F,T)
names(rqm)[6]<-"pvalue"
rqm <- filter(rqm, slope==T ) %>% #rename(species=type) %>%
  select(MetaType,species,param,Tau,Value:pvalue)

require(pander)
pandoc.table(rqm,round=2)
group_by(rqm,MetaType,type,param) %>% filter(pvalue<0.05) %>% summarise(n=n())


```

# Simulations to make a video of percolation

```{r gensimul_spat_256_32_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")

m =  0.0001596079
alfa=2.038974
side <- 256
nsp <- 32
nSimul <- 1


ReplRate <- c(0.0011)
time <- 3000

require(animation)
simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",time,10,100,"L",T,T)

saveGIF(simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",1000,10,800,"L",T,F), 
        interval = .3, 
        movie.name=paste0("neuL",nsp,"_",side,"R", ReplRate,".gif")
)


ReplRate <- c(0.0029)
time <- 3000
simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",time,10,10,"L",T,T)

saveGIF(simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",1100,10,850,"L",T,F), 
        interval = .5, 
        movie.name=paste0("neuL",nsp,"_",side,"R", ReplRate,".gif")
)

time <- 3000
simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",time,10,100,"U",T,T)

saveGIF(simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",1600,10,1350,"U",T,F), 
        interval = .5, 
        movie.name=paste0("neuU",nsp,"_",side,"R", ReplRate,".gif")
)

# Plot simulations
# Make video


```


## Calculation of the Suvival Time of the most abundant species (Species=1) and density for side=512 time=5000 uniform metacomunity   

Survival of 1 = P(t) ~ t ^-delta
Number of 1 = N(t) ~ t^theta

```{r survivalTimel512_64_U5_T5000, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.02,0.03,0.05,0.07,0.1,0.2,0.3,0.6,1)
time <- 5000
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()

CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N")
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,time,nSimul,"N")
}

# Correct CT add variable metatype
#CT <- mutate(CT,MetaType="U")
CT1$Time <- time
CT <- rbind(CT,CT1)

setwd(oldcd)

# Calculate averages by simulations 

require(dplyr)
require(ggplot2)
mct <- group_by(CT,Repl,MetaType) %>% summarize(meanRich = mean(meanRich),meanH=mean(meanH),
                                       TMaxH=mean(TMaxH),TMaxRich=mean(TMaxRich),
                                       MaxH=mean(MaxH),MaxRich=mean(MaxRich),
                                       meanEven=mean(meanEven))

# Plots of all simulations and averages H & Richness


plot_simul_timeRH(CT,mct)

rm(kk,CT1)
save.image()

```
