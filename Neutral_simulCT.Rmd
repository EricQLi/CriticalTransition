# The critical transition between neutral and competitive communities 

I use here the following neutral model with power dispersal kernel:

<https://github.com/lsaravia/Neutral>

I generate parameter files for the simulation of neutral/hierarchical model using a uniform metacommunity distribution


```{r setup, eval=T }
load(".RData")
#simul  <- F # variable to perform or not the simulations

oldcd <-getwd()
source("R/Neutral_fun.r")

# Set the location of the binary 
#
neuBin <- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralPow"
neuBin64<- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralP64"


require(pander)
require(plyr)

panderOptions('table.split.table',Inf)
options("scipen"=100, "digits"=4)
```

## Neutral Simulations to reach steady state

* near the critical point the transient is longer. 
  

* check criteria for steady state H? see @Keymer1998 Shannon entropy of the system remain bounded to very small fluctuations around a fixed value

Now I will simulate the model to Time=3000 with a full set of parameters 
Differnt ReplacementRate and 20 repetitions 

## Analizing time series there are 4 regimes with respect to ReplacementRate=Repl

### Conclusion for 10 simulations (previous run)

1) 0 >= Repl > 0.001 
H is stabilized in a value andd have stochastic oscilations
there are 3 levels H=0.5,1.0,1.5 like quantic levels???????????????

2) 0.003 >= Repl > 0.02
An oscilating regime begins but it is not completely established

3) 0.02 >= repl > 0.1

Oscilations in H 

4) 0.1 >= Repl 1

Dominance there are oscilations until time 1000 but after that complete dominance:
long transient behaviour.
Transient is shorter when 1 is approached.

# Analizing mean H & Richness (Time=2900-3000)

The existence of the 4 regimes can be seen but more simulations are needed.

H: The change in regime is seen at Repl=0.02
Richness: clear change at Repl=0.02


```{r gensimul100_64_U30, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 100
nsp <- 64
nSimul <- 30
ReplRate <- c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.015,0.02,0.025,0.03,0.05,0.07,0.1,0.3,0.6,1)

# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,3000,nSimul,"S")
}
stopCluster(cl)

rm(cn,cl)
```


```{r plotsimul100_64_U30, eval=F,error=F,echo=F,message=F,warning=F}
setwd("Simul")
# plots of simulations
#
#CT <- data.frame()

for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,3000,nSimul)
}

setwd(oldcd)

# Calculate averages by simulations 

require(dplyr)
require(ggplot2)
mct <- group_by(CT,Repl) %>% summarize(meanRich = mean(meanRich),meanH=mean(meanH),
                                       TMaxH=mean(TMaxH),TMaxRich=mean(TMaxRich),
                                       MaxH=mean(MaxH),MaxRich=mean(MaxRich),
                                       meanEven=mean(meanEven))

# Plots of all simulations and averages H & Richness

plot_simul_timeRH(CT,mct)

save.image()

```

Calculate Bray-curtis dissimilarity, Kullback-Leiber divergences and Kolmogorov-Smirnov distances between communities with differen Replacement


```{r calcDist100_64_U30, eval=F,error=F,echo=F,message=F,warning=F}
setwd("Simul")

bdist <- data.frame()
tdist <- data.frame()

for(i in 1:length(ReplRate))
  {
  kk <- calc_CommunityDist(nsp,side,alfa,m,ReplRate[c(1,i)],nSimul)

#  bdist <- rbind(bdist,data.frame(Repl=ReplRate[i],bray=mean(kk$bray),sdBray=sd(kk$bray),ks=mean(kk$ks),sdKs=sd(kk$ks),KL=mean(kk$KL),sdKL=sd(kk$KL)))
  
  tdist <- rbind(kk,tdist)
}

bdist <- group_by(tdist,ReplacementRate,ReplacementRate.1) %>% summarise(meanBray=mean(bray),medBray=median(bray),meanKS=mean(ks),medKS=median(ks),meanKL=mean(KL),medKL=median(KL)) %>% rename(Repl=ReplacementRate.1) 

tdist <- select(tdist, -X1,-Rep,-Rep.1, -ReplacementRate) %>% rename(Repl=ReplacementRate.1) %>% mutate(MetaNsp=nsp,Side=side,Disp=alfa,Migr=m) 
tdist <- tdist[,c(6:9,1:5)]

require(ggplot2)

ggplot(tdist, aes(x=Repl, y=bray)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="line",colour="red")

ggplot(tdist, aes(x=Repl, y=KL)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="line",colour="red")

ggplot(bdist, aes(x=Repl, y=meanKS)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + geom_point(aes(x=Repl,y=medKS),colour="red")

ggplot(bdist, aes(x=Repl, y=meanBray)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + geom_point(aes(x=Repl,y=medBray),colour="red")

ggplot(bdist, aes(x=Repl, y=meanKL)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))+ geom_point(aes(x=Repl,y=medKL),colour="red")


# Hacer relativo al valor de bray curtist intra neutral
setwd(oldcd)

rm(kk)
save.image()
```


Now have to plot/calculate fractal dimensions and samples of RAD for each Replacemente rate

```{r calcFrac100_64_U30, eval=T,error=F,echo=F,message=F,warning=F}
setwd("Simul")


mDq <- calc_CommunityDq(nsp,side,alfa,m,ReplRate,nSimul)

require(ggplot2)


ggplot(mDq, aes(x=Repl, y=D1)) + geom_point(size=1) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="line",colour="red")

ggplot(mDq, aes(x=Repl, y=D0)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))  + stat_summary(fun.y=median,geom="line",colour="blue")

ggplot(CT, aes(x=Repl, y=meanH)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))  + stat_summary(fun.y=median,geom="line",colour="blue")



ggplot(mct, aes(x=Repl, y=meanH)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) 
ggsave("meanH_Repl_64_100.png", width=6,height=6,units="in",dpi=600)


ggplot(bdist, aes(x=Repl, y=meanKL)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) 
ggsave("meanKL_Repl_64_100.png", width=6,height=6,units="in",dpi=600)

# reorganize to match names of CT data.frame
#
mDq <- select(mDq, -MortalityRate) %>% rename(MetaNsp=Nsp,Disp=DispersalDistance,Migr=ColonizationRate,Repl=ReplacementRate)
mDq <- ungroup(mDq)
mDq <- mDq[,c(8,9,2:7)]

# make averages

mDqA <- group_by(mDq, Repl) %>% summarise(meanD0=mean(D0), meanD1=mean(D1))


ggplot(mDqA, aes(x=Repl, y=meanD1)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) 
ggsave("meanD1_Repl_64_100.png", width=6,height=6,units="in",dpi=600)


ggplot(mDqA, aes(x=Repl, y=meanD0)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) 
ggsave("meanD0_Repl_64_100.png", width=6,height=6,units="in",dpi=600)


setwd(oldcd)
save.image()
```