# The critical transition between neutral and competitive communities 

I use here the following neutral model with power dispersal kernel:

<https://github.com/lsaravia/Neutral>

I generate parameter files for the simulation of neutral/hierarchical model using a uniform and a logseries metacommunity distribution  


```{r setup, eval=T }
load(".RData")
#simul  <- F # variable to perform or not the simulations

oldcd <-getwd()
source("R/Neutral_fun.r")

# Set the location of the binary 
#
neuBin <- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralPow"
neuBin64<- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralP64"


require(pander)
require(plyr)
require(dplyr)

panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')
options("scipen"=100, "digits"=6)
```

# Determination of the critical point using probability of spanning cluster

## Simulations for Uniform and Logseries side =100,256,512 species=64 1T=20000 


The critical probability is very low around 0.0005 thus most communities should be in a "niche" state but the transient time is very long unless rho is relatively high.



```{r gensimul_clu_side_64_meta40_T20000m0001, eval=F,echo=F,message=T,warning=T}
setwd("Simul")

m =  0.0001                  # Ver @Condit2012 
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 40

#ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

# Not done yet

ReplRate <- c(0.0000,0.0001,0.0002,0.0003,0.0004,0.0005,0.0006,0.0007,0.0008,0.0010,0.0020,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time<-      c(20000,  20000, 20000, 30000, 30000, 30000, 30000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 10000,  5000,  5000,  5000,  5000,5000)

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(192),meta=c("L","U")) 

time <-rep(time, times=nrow(p)/length(time))

p <-cbind(p,time)

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",p$time[i],nSimul,T,"N",p$meta[i],F,2)
}

# To reconstruct the data frame Clusters from the output files  
#
# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",p$time[i],nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```


# Calculation of the critical point T=20000 DispersalDistance=26 m=0.0001

```{r pcT20000_clu_side_64_meta30, eval=F,echo=F,message=T,warning=T}

m   <-0.0001
alfa <-round(2.03897,5)
side <- 256
nsp <- 64
nSimul <- 30
time <- 20000

require(plyr)
require(dplyr)

# Calculates critical probabilities for differnt side (rCTs) and critical probability for infinite lattices (rCT)
#
Clu <- filter(Clusters, Side!=64)
k <-calcCritical_prob(Clu,time,nsp,alfa,m)

require(ggplot2)
require(pander)

# Create data frame to store Pc for lattices with different sides
rhoCritSide <- data_frame()

# Update table after recalculation of critical points
#
kk <- k$rCTs
kk$Time <- 20000  
rhoCritSide <- bind_rows(rhoCritSide,kk)
pandoc.table(rhoCritSide,round=5)

# Create data frame to store Pc for infinite lattices
rhoCrit <- data_frame()
# rhoCrit$Time <-5000
# 
#rhoCrit <- filter(rhoCrit,DispersalDistance!=26.66 | ColonizationRate!=0.000159608 | MetaNsp!=64)
kk <- k$rCT
kk$Time <- 20000  
rhoCrit <- bind_rows(rhoCrit,kk)
pandoc.table(rhoCrit,round=5)

# Make with different sides filter side=150
# 
k<-filter(rhoCritSide,Time==time,MetaNsp==nsp,DispersalDistance==round(mean_power(alfa),2),ColonizationRate==m,Side!=64)
k$MetaType <- factor(k$MetaType,labels=c("Logseries","Uniform"))

mClusters <- filter(Clusters, MetaNsp==nsp,DispersalDistance==alfa,ColonizationRate==m,Side!=64) %>%  group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance,ColonizationRate) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))  %>% ungroup() %>% mutate(MetaType=factor(MetaType,labels=c("Logseries","Uniform")))

#
# Spaninng probability vs rho
#
require(RColorBrewer)
colp <-brewer.pal(8,"Dark2")

ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10() + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour=colp[1]) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6]) + ylab("Probability of spanning cluster")+  theme(axis.text.x=element_text(angle=-30, vjust=0.9,hjust = 0.1)) 
ggsave("figs/SpanPvsRepl_T20000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# The same Plot in linear x scale 
#
ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + coord_cartesian(xlim=c(0, 0.01)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour=colp[1]) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6]) + ylab("Probability of Spanning cluster")
ggsave("figs/SpanPvsRepl_T20000_64_side_meta_lin.png", width=6,height=6,units="in",dpi=600)


#
# Shannon diversity vs rho
#
tClusters <- Clusters %>% filter(MetaNsp==nsp,DispersalDistance==alfa,ColonizationRate==m,Side!=64)  %>% mutate(MetaType=factor(MetaType,labels=c("Logseries","Uniform")))

#
# H vs rho
#
ggplot(tClusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.1) + theme_bw() + scale_x_log10() + stat_summary(fun.y=median,geom="line",colour=colp[1])+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6])
ggsave("figs/HvsRepl_T20000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# H vs rho in linear x scale 
#
ggplot(tClusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.1) + theme_bw() + coord_cartesian(xlim=c(0, 0.005)) + stat_summary(fun.y=median,geom="line",colour=colp[1])+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6]) + theme(panel.margin.x=unit(0.6, "lines"))
ggsave("figs/HvsRepl_T20000_64_side_meta_lin.png", width=6,height=6,units="in",dpi=600)


#
# Richness vs rho
#
ggplot(tClusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10() + stat_summary(fun.y=mean,geom="line",colour=colp[1])+ facet_grid(Side ~ MetaType,scales="free_y") +xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6])
ggsave("figs/RichvsRepl_T20000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# Richness vs rho linear scale
#
ggplot(tClusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + stat_summary(fun.y=mean,geom="line",colour=colp[1])+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6])


#
# Plot of Spanning clusters sizes with critical probability
#
ggplot(tClusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.1) + theme_bw() + scale_x_log10() + stat_summary(fun.y=mean,geom="line",colour=colp[1])+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6])

ggsave("figs/SpanClusRepl_T20000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# The same Plot in linear x scale 
#
ggplot(tClusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.2) + theme_bw() + xlim(0,0.02)  + stat_summary(fun.y=mean,geom="line",colour=colp[1])+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour=colp[6])


rm(kk,k,k1,p,mClusters,tClusters,Clu)
```

## Plot SAD for side=128,254 U & L metacommunity

```{r plotsad_256_64_U30, eval=F,echo=F,message=T,warning=T}
setwd("Simul")

m   <-0.0001
alfa <-round(2.03897,5)
time<-      c(20000,  20000, 30000, 20000, 20000, 20000,  5000, 5000, 5000)
ReplRate <- c(0.0000,0.0001,0.0005,0.0010,0.0050,0.0100,0.1000,0.3000,1)

plotNeutral_SAD_1T(64,128,ReplRate,time,m,alfa)

plotNeutral_SAD_1T(64,256,ReplRate,time,m,alfa)

plotNeutral_SAD_1T(64,128,ReplRate,time,m,alfa,"L")

plotNeutral_SAD_1T(64,256,ReplRate,time,m,alfa,"L")


# Plots of logseries and uniform metacommunity SAD 

#
# time around 20000
#
options("scipen"=0, "digits"=4)

rank <- plotNeutral_SAD_1T(64,256,ReplRate,time,m,alfa,"L",T)
rank$MetaType="Logseries"
r1 <-  plotNeutral_SAD_1T(64,256,ReplRate,time,m,alfa,"U",T) 
r1$MetaType="Uniform"
rank <- rbind(rank,r1)
rank$Time <- 20000 
rm(r1)

options("scipen"=100, "digits"=6)
require(RColorBrewer)
mc <-brewer.pal(8,"Dark2")

colourCount = length(unique(rank$ReplacementRate))
mc1 <- colorRampPalette(mc)(colourCount)
#mc1[11]<-"#0D0D0D" # rho=0.0015
#g <- ggplot(rank,aes(x=Rank,y=log(Freq),colour=factor(ReplacementRate))) +  theme_bw() +
g <- ggplot(rank,aes(x=Rank,y=Freq,colour=factor(ReplacementRate))) +  theme_bw() + scale_y_log10() 
g + scale_colour_manual(values=mc1,name=bquote("  "~rho))  + geom_point(size=0.5) +geom_line() + facet_grid(. ~ MetaType, scales="free_x" )

setwd(oldcd)
ggsave("figs/SAD_T20000_64_256_meta.png", width=6,height=4,units="in",dpi=600)

```

## Determine critical point for m=0.01

```{r gensimul_clu_side_64_meta40_T20000m01, eval=T,echo=F,message=T,warning=T}
setwd("Simul")

m =  0.01                  # Ver @Condit2012 
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 10

ReplRate <- c(0.0000,0.0001,0.0005,0.0006,0.0007,0.0008,0.0010,0.0020,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time<-      c(10000,  10000, 20000, 30000, 30000, 30000, 30000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 20000, 10000,  5000,  5000,  5000)

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(128,192,256),meta=c("L","U")) 

time <-rep(time, times=nrow(p)/length(time))

p <-cbind(p,time)

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",p$time[i],nSimul,T,"N",p$meta[i],F,2)
}

# To reconstruct the data frame Clusters from the output files  
#
# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",p$time[i],nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```



## Simulations to Time=20000 to plot spatial patterns 

```{r gensimul_spat_256_64_meta30_T20000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 1

time<-      c(20000,  20000, 30000, 20000, 20000, 20000,  5000, 5000, 5000)
ReplRate <- c(0.0000,0.0001,0.0005,0.0010,0.0050,0.0100,0.1000,0.3000,1)

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=side,meta=c("U","L")) 
time <-rep(time, times=nrow(p)/length(time))
p <-cbind(p,time)

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
  simul_NeutralSAD(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",p$time[i],p$meta[i],F,2)
}

stopCluster(cl)

setwd(oldcd)

rm(cn,cl,Clu)

#save.image()
```

# Plot spatial patterns

```{r pltsimul_spat_512_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 1

ReplRate <- c(0.0000,0.0005,0.0010,0.0013,0.0016,0.0020,0.0050,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

ReplRate <- c(0.0000,0.0005,0.0010,0.0013)
ReplRate <- c(0.0000,0.0013,0.0020,0.0050)
time <- 5000

#ReplRate <- c(0.1)
options("scipen"=0, "digits"=4)

# only the spanning species
plotNeutral_SpatPat(nsp,side,time,meta=c("U"),ReplRate,T)
setwd(oldcd)
ggsave("figs/SpatSpan_Repl_T5000_64_256_Unif.png", width=6,height=6,units="in",dpi=600)

setwd("Simul")
ReplRate <- c(0.0000,0.0013,0.0020,0.0050)
plotNeutral_SpatPat(nsp,side,time,meta=c("L"),ReplRate,T)
setwd(oldcd)
ggsave("figs/SpatSpan_Repl_T5000_64_256_Logser.png", width=6,height=6,units="in",dpi=600)

# All species
setwd("Simul")
plotNeutral_SpatPat(nsp,side,time,meta=c("U"),ReplRate,F)
setwd(oldcd)
ggsave("figs/SpatAllSp_Repl_T5000_64_256_Unif.png", width=6,height=6,units="in",dpi=600)

plotNeutral_SpatPat(nsp,side,time,meta=c("L"),ReplRate,F)


```

## Regenerate Clusters data.frame from files in Simul folder

```{r regen_clust_512_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30
time <- 3000

require(dplyr)


mClusters <- filter(Clusters, Time==time) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))
ReplRate <- unique(mClusters$ReplacementRate)


p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 

Clu <- data.frame()
for(i in 1:nrow(p))
  {
  Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
  }

kk <-filter(Clu, Time==5000) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate,DispersalDistance) %>% summarise(n=n())

Clusters <- filter(Clusters, !(Time==5000)) #%>% distinct()

# Eliminate firs simulations with metacommunity of 86 sp
#
Clusters <- filter(Clusters, MetaNsp==64) #%>% distinct()

Clusters <-rbind(Clusters,Clu)

setwd(oldcd)

rm(mClusters,p,kk,cn,cl,Clu)

save.image()


```


## Simulations to Time=5000 with migration=0.00016 dispersal=13

```{r simuldisp13_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}

# Calculate dispersal parameter for half the mean distance from @Anand2010 DispersalDistance=13
#
ana <- read.table("Data/Anand2010_DD.dat", header=T)
m_DD <-mean(ana$DD)
m_DD <- m_DD/2
mean_power_opt <-function(alfa,x=1) abs(((alfa-1)/(alfa-2)*x)-m_DD)
optimize(mean_power_opt,c(2,4))
mean_power(2.081069)

setwd("Simul")


m <-  0.0001596079
alfa <- 2.081069
side <- 512
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```



# Calculation of the critical point T=5000 migration=0.00016 dispersal=13  (Add Side=150)

```{r pcT5000_clu_side_64_disp13, eval=F,echo=F,message=T,warning=T}

m <-  round(0.0001596079,9)
alfa <- round(2.081069,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

rhoCritSide <- rbind(rhoCritSide,k$rCTs)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)



plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1)
save.image()

```

There seem to be no big changes in critical point with regard to dispersal distance 

## Simulations to Time=5000 with migration=0.0016 dispersal distance =26.66


```{r gensimul_m10_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30
ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#time <- 100
time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```

# Plot Critical Clusters H and Richness vs Replacement rate for migration=0.0016 dispersal=26.66 (Add Side=150)

```{r pcT5000_clu_side_64_m0016_disp26, eval=F,echo=F,message=T,warning=T}

m <-  round(0.001596079,8)
alfa<-round(2.038974,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

#filter(rhoCritSide,DispersalDistance==round(mean_power(alfa),2) & ColonizationRate==m & MetaNsp==nsp)
#rhoCritSide <-filter(rhoCritSide,DispersalDistance!=round(mean_power(alfa),2) | ColonizationRate!=m | MetaNsp!=nsp)
rhoCritSide <- rbind(rhoCritSide,k$rCTs)

#filter(rhoCrit,DispersalDistance==round(mean_power(alfa),2) & ColonizationRate==m & MetaNsp==nsp)
#rhoCrit <- filter(rhoCrit,DispersalDistance!=round(mean_power(alfa),2) | ColonizationRate!=m | MetaNsp!=nsp)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)


plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1,mClusters)
save.image()
```


## Simulations to Time=5000 with migration=0.016 dispersal distance =26


```{r gensimul_m100_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.01596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30
ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#time <- 100
time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Clu <- data.frame()
# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```


# Plot critical point for m=0.016 dispersal=26.67 (add Side=150)

```{r pcT5000_clu_side_64_m016_disp26, eval=F,echo=F,message=T,warning=T}

m   <-round(0.01596079,7)
alfa <-round(2.038974,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

rhoCritSide <- rbind(rhoCritSide,k$rCTs)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)

plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1,mClusters)
save.image()

```


* With so high migration rate there is no fall in richness and the fall in H is gentler but the critical behavior is maintained, thus there is a spanning cluster but it occupies less proportion of the landscape allowing more species to coexist.


## Simulations to Time=5000 with migration=0.00016 dispersal distance =6.66

```{r simuldisp6_clu_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}

# Calculate dispersal parameter for 1/4 the mean distance from @Anand2010 DispersalDistance=13
#
# ana <- read.table("Data/Anand2010_DD.dat", header=T)
# m_DD <-mean(ana$DD)
# m_DD <- m_DD/4
# mean_power_opt <-function(alfa,x=1) abs(((alfa-1)/(alfa-2)*x)-m_DD)
# optimize(mean_power_opt,c(2,4))
# mean_power(2.17641)

setwd("Simul")


m <-  0.0001596079
alfa <- 2.17641
side <- 512
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)


time <- 5000

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```

# Plot critical point for m=0.00016 dispersal=6.67 (add Side=150)

```{r pcT5000_clu_side_64_m016_disp6, eval=F,echo=F,message=T,warning=T}


# To find the value of m
#
# filter(Clusters, Time==time,MetaNsp==nsp,DispersalDistance==alfa) %>% distinct(ColonizationRate)
m   <-round(0.0001596079,9)
alfa <-round(2.17641,5)
side <- 512
nsp <- 64
nSimul <- 30
time <- 5000

k <-calcCritical_prob(Clusters,time,nsp,alfa,m)

rhoCritSide <- rbind(rhoCritSide,k$rCTs)

rhoCrit <- rbind(rhoCrit,k$rCT)
pandoc.table(rhoCrit,round=5)

require(ggplot2)
require(dplyr)
g1 <-ggplot(filter(rhoCrit,round(DispersalDistance,1)==26.7,MetaNsp==64),aes(x=ColonizationRate,y=pcrit,colour=MetaType)) + geom_point() + geom_errorbar(aes(ymin=pcrit-pcSE, ymax=pcrit+pcSE), width=0)+ scale_x_log10(breaks=c(0.00015,0.0015,0.015)) + theme_bw() + xlab("Migration") + ylab(bquote(rho[c])) + scale_colour_discrete(guide=FALSE)
g1
ggsave("figs/CritProb_Migr_T5000_64_meta.png", width=4,height=4,units="in",dpi=600)

#rhoCrit <- mutate(rhoCrit,ColonizationRate=ifelse(ColonizationRate==0.0001596079,0.000159608,ColonizationRate))

g2 <-ggplot(filter(rhoCrit,round(ColonizationRate,9)==0.000159608,MetaNsp==64),aes(x=DispersalDistance,y=pcrit,colour=MetaType)) + geom_point() + geom_errorbar(aes(ymin=pcrit-pcSE, ymax=pcrit+pcSE), width=.1)+ theme_bw() +xlab("Dispersal Distance") + ylab(bquote(rho[c]))  + scale_colour_discrete(guide=FALSE)
g2
ggsave("figs/CritProb_Disp_T5000_64_meta.png", width=4,height=4,units="in",dpi=600)


g3 <- ggplot(filter(rhoCrit,round(ColonizationRate,9)==0.000159608,round(DispersalDistance,1)==26.7),aes(x=MetaNsp,y=pcrit,colour=MetaType)) + geom_point() + geom_errorbar(aes(ymin=pcrit-pcSE, ymax=pcrit+pcSE), width=.1)+ theme_bw() +xlab("Metacomm no. species") + ylab(bquote(rho[c]))  + scale_colour_discrete(name="Metacomm.\nType") + theme(legend.justification=c(1,0),legend.position=c(1,0))
g3
ggsave("figs/CritProb_MetaNsp_T5000_64_meta.png", width=4,height=4,units="in",dpi=600)

plotCritical_Clusters(Clusters,5000,nsp,alfa,m,k)

rm(k,k1,mClusters,g1,g2,g3)
save.image()

```

## Simulations to Time=5000 with side=150, varying migration and dispersal to add to finite size scaling 

```{r simuldisp_clu_side150_meta64_n30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


side <- 150
nsp <- 64
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

time <- 5000

m  <- 0.0001596079
alfa <-c(2.038974,2.081069,2.17641) #26,13,6.6

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(150),meta=c("U","L")) 

m <-  c(0.0001596079,0.001596079,0.01596079)
alfa <-2.038974

p <-rbind(p,expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(150),meta=c("U","L")) )

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

## OJO NO BORRA SIMULACIONES ANTERIORES!
## ultimo F!!
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()

```

## Simulations to Time=5000 with side=100-512, dispersal=26 migration=0.0001596079 species=256 

```{r simuldisp_clu_side512_meta256_n30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


side <- c(100,150,256,512)
nsp <- 256
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#ReplRate <- c(0.0000,0.0007,0.0022,0.0028)
time <- 5000

m  <- 0.0001596079
alfa <-2.038974

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=side,meta=c("U","L")) # ,"L"

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

# Last T/F deletes or not previous simulations
#
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],F)
}

# Read simulations info and add it to Clusters data.frame
#
# for(i in 1:nrow(p))
# {
#     Clu <- bind_rows(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i],F))
#   
# }

stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(p,cn,cl,Clu)

save.image()

```

```{r pcT5000_clu_side_256_meta256_disp26, eval=F,echo=F,message=T,warning=T}

side <- c(100,150,256,512)
nsp <- 256
time <- 5000

m   <-round(0.0001596079,9)
alfa <-round(2.038974,5)

rl <- calcCritical_prob(Clusters,time,nsp,alfa,m)
#rhoCritSide <- filter(rhoCritSide,MetaNsp==64)
rhoCritSide <- rbind(rhoCritSide,rl$rCTs)
rhoCrit <- rbind(rhoCrit,rl$rCT)

plotCritical_Clusters(Clusters,time,nsp,alfa,m,rhoCritSide)


```

## Simulations to Time=5000 with side=100-512, dispersal=26 migration=0.0001596079 species=16 

```{r simuldisp_clu_side512_meta16_n30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


side <- c(100,150) #c(100,150,256,512)
nsp <- 16
nSimul <- 30

ReplRate <- c(0.0000,0.0005,0.0006,0.0007,0.0008,0.0010,0.0011,0.0012,0.0013,0.0014,0.0015,0.0016,0.0017,0.0018,0.0019,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

#ReplRate <- c(0.0000,0.0007,0.0022,0.0028)
time <- 5000

m  <- 0.0001596079
alfa <-2.038974

p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=side,meta=c("U","L")) # ,"L"

# Read simulations info and add it to Clusters data.frame 
# use it in case of broken simulations

# Clu <- data.frame()
# for(i in 1:nrow(p))
# {
#     Clu <- bind_rows(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i],F))
#   
# }

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

# Last parameter to delete previous simulations
#
Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i],T)
}

stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(p,cn,cl,Clu)

save.image()
```

```{r pcT5000_clu_side_256_meta16_disp26, eval=F,echo=F,message=T,warning=T}


m   <-round(0.0001596079,9)
alfa <-round(2.038974,5)
time <- 5000
nsp<-16

rl <- calcCritical_prob(Clusters,time,nsp,alfa,m) #Exclude Side=100

# Update table after recalculation of critical points
#rhoCritSide <- filter(rhoCritSide,DispersalDistance!=26.66 | ColonizationRate!=0.000159608 | MetaNsp!=16)
rhoCritSide <- rbind(rhoCritSide,rl$rCTs)
rhoCrit <- rbind(rhoCrit,rl$rCT)

# Save figures
#
plotCritical_Clusters(Clusters,time,nsp,alfa,m,rhoCritSide,150,T)

#
# Tables for paper
#
require(pander)
pandoc.table(filter(rhoCritSide,DispersalDistance==26.66,ColonizationRate==m, MetaNsp==64) %>% select(c(1,4:6)),round=5)

options("scipen"=100, "digits"=6)
pandoc.table(select(rhoCrit,c(6,1:5)) %>% arrange(ColonizationRate,desc(DispersalDistance),MetaNsp,MetaType)
             ,round=5)

# Calculation of the relative variation of each variable
#
senRhoCri <- filter(rhoCrit,ColonizationRate==round(0.0001596079,9),MetaNsp==64) %>% group_by(MetaType) %>% summarize(var="Dispersal",delta_pc=(max(pcrit) - min(pcrit))/max(pcrit), delta_var=(max(DispersalDistance) - min(DispersalDistance))/max(DispersalDistance),rv_var=delta_pc/delta_var)

senRhoCri <- bind_rows(senRhoCri, filter(rhoCrit,ColonizationRate==round(0.0001596079,9),DispersalDistance==26.66) %>% group_by(MetaType) %>% summarize(delta_pc=(max(pcrit) - min(pcrit))/max(pcrit), delta_var=(max(MetaNsp) - min(MetaNsp))/max(MetaNsp),rv_var=delta_pc/delta_var,var="MetaNsp"))

senRhoCri <- bind_rows(senRhoCri, filter(rhoCrit,MetaNsp==64,DispersalDistance==26.66) %>% group_by(MetaType) %>% summarize(delta_pc=(max(pcrit) - min(pcrit))/max(pcrit), delta_var=(max(ColonizationRate) - min(ColonizationRate))/max(ColonizationRate),rv_var=delta_pc/delta_var,var="Colonization"))

pandoc.table(senRhoCri,round=2)

```

With 16 species and logseries community the most abundant species have a nonzero probability to form a spanning cluster, if we take out neutral communities we can still calculate a critical point.



# Simulate to estimate distributions of patch sizes statistics

```{r simuldisp26_cluAll_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd(oldcd)
source("R/powerlaw/discpowerexp.R")
source("R/powerlaw/discexp.R")
source("R/powerlaw/powerexp.R")
source("R/powerlaw/exp.R")
source("R/powerlaw/pareto.R")
source("R/powerlaw/zeta.R")

setwd("Simul")


m <-  0.0001596079
alfa <- 2.038974
side <- 256
nsp <- 64
nSimul <- 10
time <- 5000
#time <- 100
ReplRate <- c(0.0000,0.0005,0.0010,0.0020,0.0030,0.004,0.005,0.01)
p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(256),meta=c("U","L")) 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)
Models <- data.frame()
Mdl <- data.frame()
Mdl <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
    simulNeutral_Clusters(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"A",time,nSimul,F,"N",p$meta[i],F)
}

stopCluster(cl)
setwd(oldcd)

Models <- rbind(Models,Mdl)

rm(cn,cl,Mdl,p)

save.image()

```


# Plot the cluster sizes with fitted functions
 
```{r plotFitdisp26_cluAll_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
source("R/powerlaw/discpowerexp.R")
source("R/powerlaw/discexp.R")
source("R/powerlaw/powerexp.R")
source("R/powerlaw/exp.R")
source("R/powerlaw/pareto.R")
source("R/powerlaw/zeta.R")

setwd("Simul")


m <-  0.0001596079
alfa <- 2.038974
side <- 256
nsp <- 64
nSimul <- 10
time <- 5000
ReplRate <- c(0.0000,0.0005,0.0010,0.0020,0.0030,0.004,0.005,0.01)
p <-expand.grid(disp=alfa,migr=m,repl=ReplRate,side=c(256),meta=c("U","L")) 

for(i in 1:nrow(p)){
  plotNeutral_Clusters(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],time,p$meta[i],Models)
}
setwd(oldcd)

```

# Plot relation of power exponent/ exponential rate with ReplacementRate

```{r plotdisp26_cluAll_side_64_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd(oldcd)

#
# Hacer grafico con proporcion de ajustes 
require(ggplot2)
require(plyr)
require(dplyr)
Models <- ungroup(Models)


# Power laws best models 
#
nMdl <-group_by(Models,MortalityRate,DispersalDistance,ColonizationRate,ReplacementRate,MetaType,Rep) %>% filter(DeltaAIC>0, model=="PowExp")

# Proportion of best models by model only
#
group_by(Models,model) %>% filter(DeltaAIC==0)  %>% summarise(n=n()) %>% ungroup() %>% mutate(Frequency=n/sum(n))

namType <- c("Spanning","MaxPatch","Other MaxPatch","Other Spanning")
namTypeAb <- c("Spanning/+Abundant","Spanning/+Abundant","Other Species","Other Species")

mMdl <- group_by(Models,model,type) %>% filter(DeltaAIC==0)  %>% summarise(n=n()) %>% ungroup() %>% mutate(Frequency=n/sum(n),type=namType[type])

mc <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
ggplot(mMdl, aes(x=model,y=Frequency,fill=type)) + geom_bar(stat="identity") +  scale_fill_manual(values=mc,name="Species",breaks=c("Spanning","MaxPatch","Other Spanning","Other MaxPatch")) + scale_x_discrete(labels=c("No Model","Power","Power Exp.")) + theme_bw()
ggsave("figs/ClusModels_T5000_64_256_Logser.png", width=6,height=6,units="in",dpi=600)

require(pander)
pandoc.table(mMdl,round=2)


# Select Power w/exponential cutoff other sp most abundant or other spanning
#
mMdl <- filter(Models,model=="PowExp",type==3 | type==4) %>% mutate(typeAb=namTypeAb[type],type=namType[type])

# Plot lambda - exponential decay rate
#
ggplot(mMdl,aes(x=ReplacementRate,y=rate,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=median,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(lambda)) + xlab(bquote(rho))+ scale_colour_manual(values=mc) +stat_quantile(alpha=0.5) + coord_cartesian(ylim=c(-0.02,0.65))
ggsave("figs/discRateOther_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)

# Quantile regression lambda
#
#
rqm <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(rate~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="lambda")


# Plot power exponent alpha
#
mMdl <- filter(Models,model=="PowExp",type==3 | type==4) %>% mutate(typeAb=namTypeAb[type],type=namType[type])

ggplot(mMdl,aes(x=ReplacementRate,y=alfa,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=median,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(alpha)) + xlab(bquote(rho))+ scale_colour_manual(values=mc)+stat_quantile(alpha=0.5)+ coord_cartesian(ylim=c(1.1,2.1))

ggsave("figs/discExpOther_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)


# Quantile regression alpha
#
#
rq1 <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(alfa~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="alpha")

rqm <- rbind(rqm,rq1)

# Select Power w/exponential cutoff - spanning or most abundant  sp
#
mMdl <- filter(Models,model=="PowExp",type==1 | type==2) %>% mutate(typeAb=namTypeAb[type],type=namType[type])


# Plot Power exponent - alpha  of spanning or most abundant  sp
#
ggplot(mMdl,aes(x=ReplacementRate,y=alfa,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=mean,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(alpha)) + xlab(bquote(rho)) + scale_colour_manual(values=mc)+stat_quantile(alpha=0.5)+ coord_cartesian(ylim=c(1.5,3.6))
ggsave("figs/discExpSpan_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)

# Quantile regression alpha
#
#
rq1 <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(alfa~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="alpha")

rqm <- rbind(rqm,rq1)

# Select Power w/exponential cutoff - spanning or most abundant  sp
#
mMdl <- filter(Models,model=="PowExp",type==1 | type==2) %>% mutate(typeAb=namTypeAb[type],type=namType[type])

# Plot Exponential rate - lambda of spanning or  most abundant sp
#
ggplot(mMdl,aes(x=ReplacementRate,y=rate,colour=type)) + geom_point() +  theme_bw() + facet_wrap(~MetaType,scales="free_y") + stat_summary(fun.y=mean,geom="line",colour=mc[5],linetype="dashed") + scale_x_continuous(breaks=c(0,0.0010,0.0020,0.0030,0.005,0.01)) +
  theme(axis.text.x=element_text(angle=90,vjust=0.5)) + ylab(bquote(lambda)) + xlab(bquote(rho))+ scale_colour_manual(values=mc)+stat_quantile(alpha=0.5)+ coord_cartesian(ylim=c(-0.02,0.32))
ggsave("figs/discRateSpan_T5000_64_256_meta.png", width=7,height=4,units="in",dpi=600)

# Quantile regression lambda
#
#
rq1 <-group_by(mMdl,type,MetaType) %>%
      do(as.data.frame(do.call(rbind,
                               lapply(summary(rq(rate~ReplacementRate,data=.,tau=c(.25, .5, .75)),se="boot"),coef))
                       ,row.names= NULL)) %>% mutate(Tau=rep(c(.25, .5, .75),each=2),param="lambda")

rqm <- rbind(rqm,rq1)
rqm$slope<-c(F,T)
names(rqm)[6]<-"pvalue"
rqm <- filter(rqm, slope==T ) %>% #rename(species=type) %>%
  select(MetaType,species,param,Tau,Value:pvalue)

require(pander)
pandoc.table(rqm,round=2)
group_by(rqm,MetaType,type,param) %>% filter(pvalue<0.05) %>% summarise(n=n())


```

# Simulations to make a video of percolation

```{r gensimul_spat_256_32_meta30_T5000, eval=F,echo=F,message=T,warning=T}
setwd("Simul")

m =  0.0001596079
alfa=2.038974
side <- 256
nsp <- 32
nSimul <- 1


ReplRate <- c(0.0011)
time <- 3000

require(animation)
simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",time,10,100,"L",T,T)

saveGIF(simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",1000,10,800,"L",T,F), 
        interval = .3, 
        movie.name=paste0("neuL",nsp,"_",side,"R", ReplRate,".gif")
)


ReplRate <- c(0.0029)
time <- 3000
simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",time,10,10,"L",T,T)

saveGIF(simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",1100,10,850,"L",T,F), 
        interval = .5, 
        movie.name=paste0("neuL",nsp,"_",side,"R", ReplRate,".gif")
)

time <- 3000
simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",time,10,100,"U",T,T)

saveGIF(simul_NeutralSpatPatt(nsp,side,alfa,m,ReplRate,"S",1600,10,1350,"U",T,F), 
        interval = .5, 
        movie.name=paste0("neuU",nsp,"_",side,"R", ReplRate,".gif")
)

# Plot simulations
# Make video


```


## Calculation of the Suvival Time of the most abundant species (Species=1) and density for side=512 time=5000 uniform metacomunity   

Survival of 1 = P(t) ~ t ^-delta
Number of 1 = N(t) ~ t^theta

```{r survivalTimel512_64_U5_T5000, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.02,0.03,0.05,0.07,0.1,0.2,0.3,0.6,1)
time <- 5000
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()

CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N")
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,time,nSimul,"N")
}

# Correct CT add variable metatype
#CT <- mutate(CT,MetaType="U")
CT1$Time <- time
CT <- rbind(CT,CT1)

setwd(oldcd)

# Calculate averages by simulations 

require(dplyr)
require(ggplot2)
mct <- group_by(CT,Repl,MetaType) %>% summarize(meanRich = mean(meanRich),meanH=mean(meanH),
                                       TMaxH=mean(TMaxH),TMaxRich=mean(TMaxRich),
                                       MaxH=mean(MaxH),MaxRich=mean(MaxRich),
                                       meanEven=mean(meanEven))

# Plots of all simulations and averages H & Richness


plot_simul_timeRH(CT,mct)

rm(kk,CT1)
save.image()

```
