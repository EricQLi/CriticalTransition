# The critical transition between neutral and competitive communities 

I use here the following neutral model with power dispersal kernel:

<https://github.com/lsaravia/Neutral>

I generate parameter files for the simulation of neutral/hierarchical model using a uniform and a logseries metacommunity distribution  


```{r setup, eval=T }
load(".RData")
#simul  <- F # variable to perform or not the simulations

oldcd <-getwd()
source("R/Neutral_fun.r")

# Set the location of the binary 
#
neuBin <- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralPow"
neuBin64<- "~/Dropbox/cpp/CaNew/Neutral/ipsNeutralP64"


require(pander)
require(plyr)

panderOptions('table.split.table',Inf)
panderOptions('table.style', 'multiline')
options("scipen"=100, "digits"=4)
```

## Neutral Simulations to reach steady state


Now I will simulate the model wiht side=100 64 sp to Time=3000 with  
Differnt ReplacementRate and 30 repetitions 


```{r gensimul100_64_U30, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 100
nsp <- 64
nSimul <- 30
ReplRate <- c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.015,0.02,0.025,0.03,0.05,0.07,0.1,0.2,0.3,0.6,1)

# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,3000,nSimul,"S")
}
stopCluster(cl)

rm(cn,cl)
```


```{r plotsimul100_64_U30, eval=F,error=F,echo=F,message=F,warning=F}
setwd("Simul")
# plots of simulations
#
#CT <- data.frame()

for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,3000,nSimul)
}

setwd(oldcd)

# Calculate averages by simulations 

require(dplyr)
require(ggplot2)
mct <- group_by(CT,Repl) %>% summarize(meanRich = mean(meanRich),meanH=mean(meanH),
                                       TMaxH=mean(TMaxH),TMaxRich=mean(TMaxRich),
                                       MaxH=mean(MaxH),MaxRich=mean(MaxRich),
                                       meanEven=mean(meanEven))

# Plots of all simulations and averages H & Richness

plot_simul_timeRH(CT,mct)

save.image()

```

## Calculate Bray-curtis dissimilarity, Kullback-Leiber divergences and Kolmogorov-Smirnov distances 

I  use the previous simulations to calculate the distances between the neutral ReplacementRate=0 and the other communities



```{r calcDist100_64_U30, eval=F,error=F,echo=F,message=F,warning=F}
setwd("Simul")

bdist <- data.frame()
tdist <- data.frame()

for(i in 1:length(ReplRate))
  {
  kk <- calc_CommunityDist(nsp,side,alfa,m,ReplRate[c(1,i)],nSimul)

#  bdist <- rbind(bdist,data.frame(Repl=ReplRate[i],bray=mean(kk$bray),sdBray=sd(kk$bray),ks=mean(kk$ks),sdKs=sd(kk$ks),KL=mean(kk$KL),sdKL=sd(kk$KL)))
  
  tdist <- rbind(kk,tdist)
}

bdist <- group_by(tdist,ReplacementRate,ReplacementRate.1) %>% summarise(meanBray=mean(bray),medBray=median(bray),meanKS=mean(ks),medKS=median(ks),meanKL=mean(KL),medKL=median(KL)) %>% rename(Repl=ReplacementRate.1) 

tdist <- select(tdist, -X1,-Rep,-Rep.1, -ReplacementRate) %>% rename(Repl=ReplacementRate.1) %>% mutate(MetaNsp=nsp,Side=side,Disp=alfa,Migr=m) 
tdist <- tdist[,c(6:9,1:5)]

require(ggplot2)

ggplot(tdist, aes(x=Repl, y=bray)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="line",colour="red")

ggplot(tdist, aes(x=Repl, y=KL)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="line",colour="red")

ggplot(bdist, aes(x=Repl, y=meanKS)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + geom_point(aes(x=Repl,y=medKS),colour="red")

ggplot(bdist, aes(x=Repl, y=meanBray)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + geom_point(aes(x=Repl,y=medBray),colour="red")

ggplot(bdist, aes(x=Repl, y=meanKL)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))+ geom_point(aes(x=Repl,y=medKL),colour="red")


# Hacer relativo al valor de bray curtist intra neutral
setwd(oldcd)

rm(kk)
save.image()
```

## calculate information fractal dimension and species-area exponent and save figures


```{r calcFrac100_64_U30, eval=F,error=F,echo=F,message=F,warning=F}
setwd("Simul")

mDq <- calc_CommunityDq(nsp,side,alfa,m,ReplRate,nSimul)

require(ggplot2)

setwd(oldcd)

ggplot(CT, aes(x=Repl, y=meanH)) + geom_point(size=1) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))  + stat_summary(fun.y=median,geom="point",colour="red") + xlab(expression(rho))
ggsave("figs/H_Repl_T3000_64_100.png", width=6,height=6,units="in",dpi=600)

ggplot(CT, aes(x=Repl, y=meanRich)) + geom_point(size=1) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))  + stat_summary(fun.y=median,geom="point",colour="red") + xlab(expression(rho))
ggsave("figs/Rich_Repl_T3000_64_100.png", width=6,height=6,units="in",dpi=600)


ggplot(tdist, aes(x=Repl, y=bray)) +  theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="point",colour="red") + xlab(expression(rho))
ggsave("figs/Bray_Repl_T3000_64_100.png", width=6,height=6,units="in",dpi=600)


ggplot(tdist, aes(x=Repl, y=KL)) +  theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="point",colour="red") + xlab(expression(rho))
ggsave("figs/KL_Repl_T3000_64_100.png", width=6,height=6,units="in",dpi=600)

# mct = ensemble means of Rich, H ...
#
ggplot(mct, aes(x=Repl, y=meanH)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) +xlab(expression(rho))

# bdist = ensemble means of distances Bray/KL
#
ggplot(bdist, aes(x=Repl, y=meanKL)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) +xlab(expression(rho))

# reorganize to match names of CT data.frame
#
mDq <- select(mDq, -MortalityRate) %>% rename(MetaNsp=Nsp,Disp=DispersalDistance,Migr=ColonizationRate,Repl=ReplacementRate)
mDq <- ungroup(mDq)
mDq <- mDq[,c(8,9,2:7)]


ggplot(mDq, aes(x=Repl, y=D1)) + geom_point(size=1) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="point",colour="red")+  xlab(expression(rho))
ggsave("figs/D1_Repl_T3000_64_100.png", width=6,height=6,units="in",dpi=600)

ggplot(mDq, aes(x=Repl, y=D0)) + geom_point(size=1) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))  + stat_summary(fun.y=median,geom="point",colour="red") + xlab(expression(rho))
ggsave("figs/D0_Repl_T3000_64_100.png", width=6,height=6,units="in",dpi=600)


# enseble averages

# mDqA <- group_by(mDq, Repl) %>% summarise(meanD0=mean(D0), meanD1=mean(D1),medDO=median(D0),medD1=median(D1))
# 
# ggplot(mDqA, aes(x=Repl, y=meanD1)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))
# 
# ggplot(mDqA, aes(x=Repl, y=meanD0)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1))

save.image()
```



## Time series simulations for side=256 time=3000 uniform metacomunity   


```{r plotsimul256_64_U5, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 256
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.015,0.02,0.025,0.03,0.05,0.07,0.1,0.2,0.3,0.6,1)
time <- 3000
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()


CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N")
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,3000,nSimul,"N")
}

# Correct CT add variable metatype
#CT <- mutate(CT,MetaType="U")
CT <- rbind(CT,CT1)

setwd(oldcd)

# Calculate averages by simulations 

require(dplyr)
require(ggplot2)
mct <- group_by(CT,Repl,MetaType) %>% summarize(meanRich = mean(meanRich),meanH=mean(meanH),
                                       TMaxH=mean(TMaxH),TMaxRich=mean(TMaxRich),
                                       MaxH=mean(MaxH),MaxRich=mean(MaxRich),
                                       meanEven=mean(meanEven))

# Plots of all simulations and averages H & Richness

plot_simul_timeRH(CT,mct)

rm(kk,CT1)
save.image()
```


## Time series simulations for side=512 time=3000 uniform metacomunity   

```{r plotsimul512_64_U5, eval=F,echo=F,message=F,warning=F}
setwd("Simul")

# Ver Neutral_Model_BCI.Rmd por parametros
#
m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 5
ReplRate <- c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.015,0.02,0.025,0.03,0.05,0.07,0.1,0.2,0.3,0.6,1)
time <- 3000
# loop con do paralell 

require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

CT1 <- data.frame()

CT1 <- foreach(i=1:length(ReplRate),.combine='rbind') %dopar%
{
    simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],T,time,nSimul,"N")
}
stopCluster(cl)

rm(cn,cl)
for(i in 1:length(ReplRate)){
  kk <- simul_NeutralPlotTime(nsp,side,alfa,m,ReplRate[i],F,time,nSimul,"N")
}

# Correct CT add variable metatype
#CT <- mutate(CT,MetaType="U")
CT <- rbind(CT,CT1)

setwd(oldcd)

# Calculate averages by simulations 

require(dplyr)
require(ggplot2)
mct <- group_by(CT,Repl,MetaType) %>% summarize(meanRich = mean(meanRich),meanH=mean(meanH),
                                       TMaxH=mean(TMaxH),TMaxRich=mean(TMaxRich),
                                       MaxH=mean(MaxH),MaxRich=mean(MaxRich),
                                       meanEven=mean(meanEven))

# Plots of all simulations and averages H & Richness

plot_simul_timeRH(CT,mct)

rm(kk,CT1)
save.image()
```


Transient time is very long -> is this a different case of supertransients?


## Simulations for Uniform and Logseries side =100,256,512 species=64 1T=3000



The critical probability is very low around 0.002 thus most communities should be in a "niche" state but the transient time is very long unless rho is relatively high.

1. More simulations in the range 0.001 - 0.003 to calculate the critical probability, and logistic regressions

2. Dos cosas por hacer, chequear que sucede a T=5000 time series y CP

```{r gensimul_clu_side_64_meta30, eval=F,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30


#ReplRate <- c(0,0.1)
ReplRate <- c(0,0.001,0.0005,0.0014,0.0018,0.002,0.0022,0.0026,0.0028,0.003,0.004,0.005,0.006,0.007,0.009,0.01,0.015,0.02,0.025,0.03,0.05,0.07,0.1,0.2,0.3,0.6,1)

#time <- 100
time <- 3000

p <-expand.grid(disp=2.038974,migr=0.0001596079,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)


Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
  simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i])
}

# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```

# Calculation of the critical point T=3000

```{r logfit_clu_side_64_meta30, eval=F,echo=F,message=T,warning=T}

require(plyr)
require(dplyr)
mClusters <- group_by(Clusters,MetaNsp,Side,MetaType,ReplacementRate) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))


require(ggplot2)
g <- ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red")

#
# Calculates the probability of spanning cluster
#

k <-group_by(mClusters, MetaType,Side) %>% filter(SpanningProb>0.29 & SpanningProb<0.8) %>% summarise(pcrit=approx(SpanningProb,ReplacementRate,xout=0.5)$y,critClust=approx(SpanningProb,SpanningClust,xout=0.5)$y)

pandoc.table(k,round=4)

#
# finite size scaling to determine pcrit for infinite lattices
#
k1 <- group_by(k,MetaType) %>% mutate(iSide=1/(Side*Side) ) %>% do(model=lm(pcrit ~ iSide, data=.)) %>% summarise(pcrit=predict(model,newdata=data.frame(iSide=0)))                                                 
   
k1
k1$MetaType <- c("L","U") 
k1$iSide <- 0 

ggplot(k,aes(x=1/(Side*Side),y=pcrit,colour=MetaType)) + geom_point() + theme_bw() +stat_smooth(method=lm,se=F) + geom_point(data=k1,aes(x=iSide,y=pcrit),shape=21)

#
# Spaninng probability vs rho
#
ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red") + geom_vline(aes(xintercept=pcrit),k,colour="green")

#
# Shannon diversity vs rho
#
ggplot(Clusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/HvsRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# Richness vs rho
#
ggplot(Clusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y") +xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/RichvsRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)


#
# Plot of Spanning clusters sizes with critical probability
#
ggplot(Clusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")

ggsave("figs/SpanClusRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

# Fit a logistic model and plot with ggplot 
#
# lFit <- mClusters %>% do(model=glm( SpanningProb ~ ReplacementRate, family=binomial(logit), data=.))
# 
# pcrit <- double(nrow(lFit))
# fitted <- data.frame()
# 
# for(i in 1:nrow(lFit)){ 
#   kk <- lFit$model[[i]]
#   pcrit[i] <- -kk$coefficients[1]/kk$coefficients[2]
#   fitted <- rbind(fitted,data.frame(MetaNsp=lFit$MetaNsp[i],Side=lFit$Side[i],MetaType=lFit$MetaType[i],fit=kk$fitted))
# }
# 
# fitted$ReplacementRate <- mClusters$ReplacementRate 
# fitted$SpanningProb <- mClusters$SpanningProb 
# 
# ggplot(fitted, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=median,geom="line",colour="red")+ facet_grid(Side ~ MetaType ) + geom_line(aes(x=ReplacementRate,y=fit))

```

## Conclusions if a species have a spanning cluster of about 30% of the total area, they are near the critical point.

## Plot SAD for side=100,254 uniform metacommunity

```{r plotsad_256_64_U30, eval=F,echo=F,message=T,warning=T}

time <- 3000
ReplRate <- c(0.0000,0.0010,0.0020,0.0030,0.0040,0.0100,0.0200,0.0500,0.1000,1)
setwd("Simul")

plotNeutral_SAD_1T(64,100,ReplRate,time)

plotNeutral_SAD_1T(64,256,ReplRate,time)

plotNeutral_SAD_1T(64,100,ReplRate,time,"L")

plotNeutral_SAD_1T(64,256,ReplRate,time,"L")

setwd(oldcd)

# Plots of logseries and uniform metacommunity SAD 

setwd("Simul")
mc <- c("#fdae61","#f46d43","#d73027","#a50026","#fee090","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695")
#ReplRate <- c(0.0000,0.0010,0.0020,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)

rank <- plotNeutral_SAD_1T(64,512,ReplRate,time,"L",T)
rank$MetaType="L"
r1 <-  plotNeutral_SAD_1T(64,512,ReplRate,time,"U",T) ##### ALGO ANDA MAL!
r1$MetaType="U"
rank <- rbind(rank,r1)
rm(r1)

g <- ggplot(rank,aes(x=Rank,y=log(Freq),colour=factor(ReplacementRate))) +  theme_bw() + geom_point(size=1,shape=c(21))
g + scale_colour_manual(values=mc,name=bquote("  "~rho))  + geom_line() + facet_grid(. ~ MetaType, scales="free_x" )
#g + scale_colour_discrete(name=bquote("  "~rho))  + geom_line() + facet_grid(. ~ MetaType, scales="free_x" )
setwd(oldcd)
ggsave("figs/SAD_T3000_64_512_meta.png", width=6,height=6,units="in",dpi=600)




#
# What happens at time=5000
#
setwd("Simul")
time <- 5000
rank <- plotNeutral_SAD_1T(64,512,ReplRate,time,"L",T)
rank$MetaType="L"
r1 <-  plotNeutral_SAD_1T(64,512,ReplRate,time,"U",T) ##### ALGO ANDA MAL!
r1$MetaType="U"
rank <- rbind(rank,r1)
rm(r1)

## DIBUJAR PATRON ESPACIAL CON SPANNING CLUSTERS!!!
```

## Simulations to Time=5000 

```{r gensimul_clu_side_64_meta30_T5000, eval=T,echo=F,message=T,warning=T}
setwd("Simul")


m =  0.0001596079
alfa=2.038974
side <- 512
nsp <- 64
nSimul <- 30


#ReplRate <- c(0,0.1)
ReplRate <- c(0.0000,0.0005,0.0010,0.0014,0.0018,0.0020,0.0022,0.0026,0.0028,0.0030,0.0040,0.0050,0.0060,0.0070,0.0090,0.0100,0.0150,0.0200,0.0500,0.1000,0.3000,1)
#time <- 100
time <- 5000

p <-expand.grid(disp=2.038974,migr=0.0001596079,repl=ReplRate,side=c(100,256,512),meta=c("U","L")) 


require(doParallel)
cn <-detectCores()
cl <- makeCluster(cn)
registerDoParallel(cl)

Clu <- data.frame()
Clu <- foreach(i=1:nrow(p),.combine='rbind') %dopar%
{
  simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,T,"N",p$meta[i])
}

# for(i in 1:nrow(p))
#   {
#   Clu <- rbind(Clu,simulNeutral_1Time(nsp,p$side[i],p$disp[i],p$migr[i],p$repl[i],"S",time,nSimul,F,"N",p$meta[i]))
#   }


stopCluster(cl)

Clusters <-rbind(Clusters,Clu)
setwd(oldcd)

rm(cn,cl,Clu)

save.image()
```


# Calculation of the critical point T=5000

```{r pcT5000_clu_side_64_meta30, eval=F,echo=F,message=T,warning=T}

require(plyr)
require(dplyr)
mClusters <- filter(Clusters, Time==5000) %>% group_by(MetaNsp,Side,MetaType,ReplacementRate) %>% summarise(MaxClusterProp=median(MaxClusterProp),n=n(),SpanningProb=sum(ifelse(SpanningSpecies>0,1,0))/n,SpanningClust=mean(SpanningClust))


require(ggplot2)
g <- ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red")
g
#
# Calculates the probability of spanning cluster
#

k <- group_by(mClusters, MetaType,Side) %>% filter(SpanningProb>0.050 & SpanningProb<0.75,ReplacementRate>0) %>% summarise(pcrit=approx(SpanningProb,ReplacementRate,xout=0.5)$y,critClust=approx(SpanningProb,SpanningClust,xout=0.5)$y)

pandoc.table(k,round=4)

#
# finite size scaling to determine pcrit for infinite lattices
#
k1 <- group_by(k,MetaType) %>% mutate(iSide=1/(Side*Side) ) %>% do(model=lm(pcrit ~ iSide, data=.)) %>% summarise(pcrit=predict(model,newdata=data.frame(iSide=0)))                                                 
   
k1
k1$MetaType <- c("L","U") 
k1$iSide <- 0 

ggplot(k,aes(x=1/(Side*Side),y=pcrit,colour=MetaType)) + geom_point() + theme_bw() +stat_smooth(method=lm,se=F) + geom_point(data=k1,aes(x=iSide,y=pcrit),shape=21)

#
# Spaninng probability vs rho
#
ggplot(mClusters, aes(x=ReplacementRate, y=SpanningProb)) + geom_point() + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + facet_grid(Side ~ MetaType ) +xlab(bquote(rho)) + geom_line(colour="red") + geom_vline(aes(xintercept=pcrit),k,colour="green")

#
# Shannon diversity vs rho
#
ggplot(Clusters, aes(x=ReplacementRate, y=H)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y" )+xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/HvsRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

#
# Richness vs rho
#
ggplot(Clusters, aes(x=ReplacementRate, y=Richness)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType,scales="free_y") +xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")
ggsave("figs/RichvsRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)


#
# Plot of Spanning clusters sizes with critical probability
#
ggplot(Clusters, aes(x=ReplacementRate, y=SpanningClust)) + geom_point(alpha=.2) + theme_bw() + scale_x_log10(breaks=c(0.003,0.02,0.1,1)) + stat_summary(fun.y=mean,geom="line",colour="red")+ facet_grid(Side ~ MetaType ) + ylab("Spanning Cluster Size") + xlab(bquote(rho)) + geom_vline(aes(xintercept=pcrit),k,colour="green")

ggsave("figs/SpanClusRepl_T3000_64_side_meta.png", width=6,height=6,units="in",dpi=600)

```
